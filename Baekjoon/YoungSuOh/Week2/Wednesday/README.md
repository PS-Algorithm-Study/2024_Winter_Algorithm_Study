# 1495번 문제 해결 과정 및 피드백

## 시간내 해결 여부
- 미해결

## 초기 아이디어
- **bfs:** 시작 지점으로부터 시작하여 볼륨 리스트마다 2가지의 경로로 나뉘기 때문에 `BFS` 문제라고 생각하고 접근을 하였다.
- 볼륨 리스트 V를 `deque`으로 선언하여 값을 삽입할 때는 push_back, 현재의 위치인 `cur`과 비교하면서 값을 pop시킬 때는 pop_front를 이용하였다.
- `queue`를 선언해 0부터 M까지 벗어나지 않는 경로를 'queue'에 push해주고, 이후 이진트리로 비교해나가면서 pop을 시키는 알고리즘을 짜려고 했다.


## 문제점 및 깨달음
- 첫번째 testcase에서는 바르게 정답이 나오지만, 두번째부터 빈 `deque`에 front() 함수를 호출하는 경우가 발생하여 `Segment Fault` 오류가 났다.
- **BFS의 시간복잡도:** BFS로 문제를 접근하면 O(2^N) time에 시간복잡도가 걸린다는 것을 시험시간 이후 깨달았다. 2^1000이면 엄청나게 큰 숫자이기에 2초안에 절대로 통과할 수 없다.

## 해결
- `DP 알고리즘`을 사용하여 문제를 해결하는 방법을 구글링을 통해 참고하여 코드를 작성했다.
- `n번째 볼륨값`은 `n-1번째`까지 조절한 모든 볼륨에서 `n번째 볼륨`을 + or - 를 해준 값
- `n-1번째 볼륨값`은 `n-2번째`까지 조절한 모든 볼륨에서 `n-1번째 볼륨`을 + or - 를 해준 값
...
- '1번째 볼륨값`은 `0번째`까지 조절한 모든 볼륨에서 `1번째 볼륨`을 + or - 를 해준 값
- 위의 아이디어를 기반으로 dp를 정의해보면 다음과 같다.
   dp[i][j] = 1 // i번째 볼륨 결과값 중 j 존재
   dp[i][j] = 0 // i번째 볼륨 결과값 중 j 존재하지 않음
- 출력값은 마지막 볼륨의 결과값 dp[n]의 배열 안에 있다. dp[n][m]부터 m을 1식 감소시키면서 값이 1이면 m을 출력하고 모든 값이 0이면 가능한 값이 없다는 뜻이므로 -1을 출력한다.


## 피드백 및 소감
- `bfs 알고리즘`도 문제에 따라 시간복잡도가 엄청나게 커진다는 사실을 인지해야겠다는 생각이 들었다.
- `Segment Fault` 잡는 것이 어려운 일도 아닌데, 빠르게 잡지 못한 것을 보면 숙련도가 부족하다는 것을 느꼈다.
- `DP 알고리즘` 점화식 세우기를 연습좀 해야겠다는 생각이 들었다.
